<?php

namespace App\Generators;

use Illuminate\Support\Facades\File;

abstract class BaseGenerator
{
    protected string $zeriPath;

    protected string $outputPath;

    public function __construct(string $zeriPath, string $outputPath)
    {
        $this->zeriPath = $zeriPath;
        $this->outputPath = $outputPath;
    }

    abstract public function generate(bool $force = false, bool $backup = false, bool $interactive = false): bool;

    abstract public function getOutputFileName(): string;

    public function getGeneratedFiles(): array
    {
        // Default implementation returns single output file
        return [$this->getOutputFileName()];
    }

    protected function shouldRegenerate(bool $force, ?string $outputFile = null): bool
    {
        if ($force) {
            return true;
        }

        $outputFile = $outputFile ?: $this->outputPath.'/'.$this->getOutputFileName();

        if (! File::exists($outputFile)) {
            return true;
        }

        $outputTime = File::lastModified($outputFile);

        // Check if any .zeri files are newer than the output file
        $zeriFiles = $this->getZeriFiles();

        foreach ($zeriFiles as $file) {
            if (File::exists($file) && File::lastModified($file) > $outputTime) {
                return true;
            }
        }

        return false;
    }

    protected function shouldBackupExisting(): bool
    {
        return $this->outputPath !== getcwd();
    }

    protected function createBackup(string $outputFile): string
    {
        if (! File::exists($outputFile)) {
            return '';
        }

        $timestamp = date('Y-m-d_H-i-s');
        $backupFile = $outputFile.'.backup.'.$timestamp;
        File::copy($outputFile, $backupFile);

        return $backupFile;
    }

    protected function detectManualModifications(string $outputFile): bool
    {
        if (! File::exists($outputFile)) {
            return false;
        }

        $content = File::get($outputFile);

        // Check for common indicators of manual editing
        $indicators = [
            '<!-- MANUAL EDIT -->',
            '<!-- USER MODIFIED -->',
            '<!-- DO NOT REGENERATE -->',
        ];

        foreach ($indicators as $indicator) {
            if (str_contains($content, $indicator)) {
                return true;
            }
        }

        // Check if file lacks generation marker
        $generationMarkers = [
            'Generated with Zeri',
            'Auto-generated by Zeri',
            'This file was generated',
        ];

        $hasGenerationMarker = false;
        foreach ($generationMarkers as $marker) {
            if (str_contains($content, $marker)) {
                $hasGenerationMarker = true;
                break;
            }
        }

        return ! $hasGenerationMarker;
    }

    protected function handleExistingFile(string $outputFile, bool $backup, bool $interactive): bool
    {
        if (! File::exists($outputFile)) {
            return true; // No existing file, proceed
        }

        $hasManualChanges = $this->detectManualModifications($outputFile);

        // If interactive mode and manual changes detected, ask user
        if ($interactive && $hasManualChanges) {
            $relativePath = str_replace($this->outputPath.'/', '', $outputFile);
            echo "File {$relativePath} appears to have manual modifications.\n";
            echo 'Do you want to overwrite it? [y/N]: ';
            $handle = fopen('php://stdin', 'r');
            $response = trim(fgets($handle));
            fclose($handle);

            if (! in_array(strtolower($response), ['y', 'yes'])) {
                return false; // User chose not to overwrite
            }
        }

        // Create backup if requested or if we're in the project root
        if ($backup || ($hasManualChanges && $this->shouldBackupExisting())) {
            $backupFile = $this->createBackup($outputFile);
            if ($backupFile) {
                $relativePath = str_replace($this->outputPath.'/', '', $outputFile);
                $relativeBackup = str_replace($this->outputPath.'/', '', $backupFile);
                echo "Created backup: {$relativeBackup}\n";
            }
        }

        return true;
    }

    protected function getZeriFiles(): array
    {
        $files = [];

        // Core files
        $coreFiles = [
            'project.md',
            'development.md',
        ];

        foreach ($coreFiles as $file) {
            $files[] = $this->zeriPath.'/'.$file;
        }

        // Specification files
        $specsDir = $this->zeriPath.'/specs';
        if (File::exists($specsDir)) {
            $specFiles = File::files($specsDir);
            foreach ($specFiles as $file) {
                $files[] = $file->getPathname();
            }
        }

        return $files;
    }

    protected function readFile(string $relativePath): string
    {
        $fullPath = $this->zeriPath.'/'.$relativePath;

        return File::exists($fullPath) ? File::get($fullPath) : '';
    }

    protected function getSpecifications(): array
    {
        $specsDir = $this->zeriPath.'/specs';
        $specs = [];

        if (File::exists($specsDir)) {
            $specFiles = File::files($specsDir);
            foreach ($specFiles as $file) {
                $specs[] = [
                    'name' => pathinfo($file->getFilename(), PATHINFO_FILENAME),
                    'content' => File::get($file->getPathname()),
                ];
            }
        }

        return $specs;
    }

    protected function writeOutput(string $content): bool
    {
        $outputFile = $this->outputPath.'/'.$this->getOutputFileName();

        // Ensure the directory exists
        $directory = dirname($outputFile);
        if (! File::exists($directory)) {
            File::makeDirectory($directory, 0755, true);
        }

        return File::put($outputFile, $content) !== false;
    }

    protected function writeFile(string $filename, string $content): bool
    {
        $outputFile = $this->outputPath.'/'.$filename;

        // Ensure the directory exists
        $directory = dirname($outputFile);
        if (! File::exists($directory)) {
            File::makeDirectory($directory, 0755, true);
        }

        return File::put($outputFile, $content) !== false;
    }

    protected function createFromStub(string $stubName, array $replacements): string
    {
        $stubPath = app_path('../stubs/'.$stubName);

        if (! File::exists($stubPath)) {
            throw new \Exception("Stub file not found: {$stubPath}");
        }

        $content = File::get($stubPath);

        foreach ($replacements as $placeholder => $value) {
            // Convert literal \n to actual newlines
            $processedValue = str_replace('\\n', "\n", $value);
            $content = str_replace('{{'.$placeholder.'}}', $processedValue, $content);
        }

        return $content;
    }
}
